# oh-my-infra-learning

- The whole GitHub flow to build and push an image, allow it to connect to the DB on AWS, and deployment the application
  - ⛴️Build the image from the dockerfile in the directory

  _Important notes_
    - If docker-compose.yaml is used, it will not build an image that combines both database and the actual application (i.e.: SpringBoot/Go server application).Instead, the created container combines the 2 containers. Therefore, it's very handy to use that to fast test the applications. Also, the entrypoint in docker-compose will override that in Dockerfile.
        - Example:
          ``` 
          services:
            mysqlservice:
              image: mysql:8.0
              environment: 
                MYSQL_ROOT_PASSWORD: secret1
                MYSQL_DATABASE: fullstackdemo
            api:
              build:
                context: .
                dockerfile: Dockerfile
              ports:
                - "8080:8080"
              environment:
                - spring.datasource.url=jdbc:mysql://root:secret1@mysqlservice:3306/fullstackdemo
              depends_on:
                - mysqlservice
              entrypoint: ["java", "-jar", "app.jar"]
          ```
    - However, for the deployment purpose (on K8S), the image generated by Dockerfile (and pushed to docker registry should be used).
    - The container needs to connect to mysql service, which's also deployed on some pods.
        - Example:
          ```
          # Use an official OpenJDK runtime as a parent image
          FROM openjdk:25-jdk-slim
          
          # Set the working directory in the container
          WORKDIR /app
          
          # Copy the application's JAR file to the container
          COPY target/*.jar app.jar
          
          # Expose the port the app runs on
          EXPOSE 8080
          
          ENTRYPOINT [ "java", "-jar", "app.jar"]
          ```

- When using AWS ECR for the registry of image, the access key and access secrets on GitHub Action need to be an IAM user with specific permissions, which could be created on IAM console.
    - Permissions:
      ```
      AmazonEC2ContainerRegistryFullAccess
      eks:DescribeCluster
      SecretsManagerReadWrite (to retrieve password to the database)
      ```
- SecretsManager
  - General steps: 
    - Use Jq to get the KV pair of secrets
      ```
      aws secretsmanager get-secret-value --secret-id {{secret id on secret manager}}  --query SecretString --output text | jq -r  'to_entries|map("\(.key)=\(.value)")|.[]'
      ```
    - Create the elastic container registry on AWS to push the image
    - Log-in to ECR
      - Workflow example
      ```
       - name: Login to Amazon ECR
         id: login-ecr
         uses: aws-actions/amazon-ecr-login@v1
      ```
    - Push the image to the pre-created repo on the registry
      ```
      run: |
        docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG -t $ECR_REGISTRY/$ECR_REOSITORY:latest .
        docker push -a $ECR_REGISTRY/$ECR_REPOSITORY
      ```


